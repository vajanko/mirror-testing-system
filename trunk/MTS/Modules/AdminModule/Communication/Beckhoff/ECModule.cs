using System;
using System.Globalization;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;

using TwinCAT.Ads;

namespace MTS.AdminModule
{
    public sealed class ECModule : IModule
    {
        #region Channels alocated memory

        // connection object
        private TcAdsClient client = new TcAdsClient();

        // all channels
        private List<ECChannel> inputs = new List<ECChannel>();
        private BinaryWriter iWriter;      // input writer
        private AdsStream iReadStream;     // input read stream
        private int iReadStreamOffset;
        private const int readCommand = 0xF080;     // constant that is entered to method call when reading

        // only output channels
        private List<ECChannel> outputs = new List<ECChannel>();
        private BinaryWriter oWriter;   // output writer
        private AdsStream oReadStream;  // output read stream
        private int oWriterOffset;      // 
        private const int writeCommand = 0xF081;    // constant that is entered to method call when writing

        #endregion

        /// <summary>
        /// (Get/Set) Name of task in TwinCAT IO Server. This name is necassary for variable handles
        /// </summary>
        public string TaskName { get; set; }

        #region IModule Members

        /// <summary>
        /// Establish a connection to ADS device
        /// </summary>
        public void Connect()
        {
            // use local netId
            client.Connect(AmsNetId.Local, 301);
        }

        public void Update(TimeSpan time)
        {   // for debuggind purpose only
        }

        /// <summary>
        /// Read all input and write all output channels
        /// </summary>
        public void Update()
        {
            writeChannels();
            readChannels();
        }
        /// <summary>
        /// Read all inputs and outputs channels
        /// </summary>
        public void UpdateInputs()
        {
            readChannels();
        }
        /// <summary>
        /// Write all outputs channels
        /// </summary>
        public void UpdateOutputs()
        {
            writeChannels();
        }

        /// <summary>
        /// Close connection between local computer and some hardware component
        /// </summary>
        public void Disconnect()
        {
            client.Dispose();
            // delete variable handles
            for (int i = 0; i < inputs.Count; i++)
                client.DeleteVariableHandle(inputs[i].IndexOffset);
        }

        /// <summary>
        /// Get an instance of paricular channel identified by its name. Return null if ther is no such a channel.
        /// In case of Beckhoff (EtherCAT) IModule implementation this is TwinCAT IO Server variable name.
        /// </summary>
        /// <param name="name">Unic name (identifier) of required channel</param>
        public IChannel GetChannelByName(string name)
        {
            for (int i = 0; i < inputs.Count; i++)
                if (inputs[i].Name == name)     // look for channel with paricular name
                    return inputs[i];
            return null;        // channel with name "name" was not found
        }

        /// <summary>
        /// Load configuration of channels form file. In case of EtherCAT (Beckhoff) implementation
        /// this file should be .CSV file generated by TwinCAT System Manager. When configuration is being
        /// loaded, must be connected already.
        /// </summary>
        /// <param name="filename">Path to file where configuration of channels is stored</param>
        public void LoadConfiguration(string filename)
        {
            if (!client.IsConnected)    // we need to get variable handles - for this connection is necessary
                Connect();

            // When loading channels: all of them are added to inputs and they are added to this collection
            // Some of these channels are also outputs - to write them when channels are update, add them to
            // outputs collection

            // parse TwinCAT configuration file
            ECDigitalInput input;
            for (int i = 0; i < 16; i++)
            {
                input = new ECDigitalInput()
                {
                    Name = "Term3_"+(i+1).ToString(),
                    FullName = "Task1.Inputs.Term3_" + (i + 1).ToString(),
                    Size = 1,
                    IndexGroup = (int)AdsReservedIndexGroups.SymbolValueByHandle,
                    IndexOffset = client.CreateVariableHandle("Task1.Inputs.Term3_" + (i + 1).ToString())
                };
                inputs.Add(input);
            }
            ECDigitalInput output;
            for (int i = 0; i < 16; i++)
            {
                output = new ECDigitalInput()
                {
                    Name = "Term4_" + (i + 1).ToString(),
                    FullName = "Task1.Outputs.Term4_" + (i + 1).ToString(),
                    Size = 1,
                    IndexGroup = (int)AdsReservedIndexGroups.SymbolValueByHandle,
                    IndexOffset = client.CreateVariableHandle("Task1.Outputs.Term4_" + (i + 1).ToString())
                };
                inputs.Add(output);
                outputs.Add(output);
                output.SetValue(true);
            }

            ECAnalogInput ain = new ECAnalogInput
            {
                Name = "Term2Ch1_2",
                FullName = "Task1.Inputs.Term2Ch1_2",
                Size = 2,
                IndexGroup = (int)AdsReservedIndexGroups.SymbolValueByHandle,
                IndexOffset = client.CreateVariableHandle("Task1.Inputs.Term2Ch1_2")
            };
            inputs.Add(ain);

            ECAnalogOutput aout = new ECAnalogOutput
            {
                Name = "Term2Ch1_2",
                FullName = "Task1.Outputs.Term2Ch1_2",
                Size = 2,
                IndexGroup = (int)AdsReservedIndexGroups.SymbolValueByHandle,
                IndexOffset = client.CreateVariableHandle("Task1.Outputs.Term2Ch1_2")
            };
            aout.Value = 321;
            inputs.Add(aout);
            outputs.Add(aout);

            alocateChannels();  // alocat memory for reading a writing channels
        }

        #endregion

        #region Channel manipulation

        private void readChannels()
        {
            // jump at the beginning of the read stream - readed data are going to be written here
            iReadStream.Seek(0, SeekOrigin.Begin);
            // read data from hardware to read stream
            client.ReadWrite(readCommand, inputs.Count, iReadStream, (AdsStream)iWriter.BaseStream);
            // jump at the beginng of the data (skip error codes)
            iReadStream.Seek(iReadStreamOffset, SeekOrigin.Begin);

            // remove this
            BinaryReader reader = new BinaryReader(iReadStream);

            // read values from stream and write to input channels
            for (int i = 0; i < inputs.Count; i++)
                inputs[i].ValueBytes = reader.ReadBytes(inputs[i].Size);
        }

        private void writeChannels()
        {
            // seek to position behid info data (IndexGroup, IndexOffset and Size), bytes before never change
            oWriter.Seek(oWriterOffset, SeekOrigin.Begin);
            // write channels values
            for (int i = 0; i < outputs.Count; i++)     
                oWriter.Write(outputs[i].ValueBytes);

            // write values from stream to hardware
            client.ReadWrite(writeCommand, outputs.Count, oReadStream, (AdsStream)oWriter.BaseStream);

            // error codes are not checked - in oReadStream
        }

        private void alocateChannels()
        {
            // 1. allocate memory for input channels
            int count = inputs.Count;  // number of items to read
            // for each variable readed from hardware 4 more bytes for error status are necessary
            int readLength = count * 4;     // we are going to skip these bytes when reading inputs
            // position in the stream where value for reading begins, before are only error codes
            iReadStreamOffset = readLength;
            // Information about reading variables are stored in a stream. We put this values to stream
            // throught BinaryWriter. This is space necessary for additional info about reading variable:
            // IndexGroup, IndexOffset, Size - 4B for each item
            int writeLength = count * 12;

            iWriter = new BinaryWriter(new AdsStream(writeLength));
            for (int i = 0; i < count; i++)
            {
                iWriter.Write(inputs[i].IndexGroup);
                iWriter.Write(inputs[i].IndexOffset);
                iWriter.Write(inputs[i].Size);
                readLength += inputs[i].Size;       // count size of readed memory (+error codes)
            }
            // to this stream data are going to be read - size is sum of all variable sizes + error codes
            iReadStream = new AdsStream(readLength);


            // 2. allocate memory for writing channels
            count = outputs.Count;  // number of items to write
            // For each variable writed an error code (4B size) is returned. This is size of memory for all error codes
            readLength = count * 4;
            // Information about writing variables are stored in a stream. We put this values to stream
            // throught BinaryWriter. This is space necessary for additional info about writing variable:
            // IndexGroup, IndexOffset, Size - 4B for each item
            writeLength = count * 12;       // but that is not all - add space for values of writing channels
            oWriterOffset = writeLength;    // position in the stream where values for writing begins, before are only info data
            for (int i = 0; i < count; i++) // add memory for each variable that is going to be written
                writeLength += outputs[i].Size;            

            // create BinaryWriter and write info data about every variable (channel)
            oWriter = new BinaryWriter(new AdsStream(writeLength));
            for (int i = 0; i < count; i++)
            {
                oWriter.Write(outputs[i].IndexGroup);    // notice that data are writed at the end
                oWriter.Write(outputs[i].IndexOffset);
                oWriter.Write(outputs[i].Size);
            }
            // when writing add data at the end of this writer - oWriterOffset points here

            // to this stream error codes will be written
            oReadStream = new AdsStream(readLength);
        }

        #endregion

        #region Constructors

        public ECModule()
        {
            TaskName = "Task1";     // set some default task name - this is default also for TwinCAT
        }

        #endregion
    }
}
